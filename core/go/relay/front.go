package main

import (
  "bufio"
  "encoding/json"
  "fmt"
  "github.com/adarqui/darkness/core/go/lib/config"
  "github.com/adarqui/darkness/core/go/lib/events"
  "github.com/adarqui/darkness/core/go/lib/redis"
  "github.com/satori/go.uuid"
  "log"
  "net"
  "os"
  "sync"
  "time"
)

type Channels struct {
  IrcSendCh chan darkness_events.Event
  IrcRecvCh chan darkness_events.Event
}

func usage() {
  fmt.Println("usage: ./front <config_file>")
  os.Exit(1)
}

func main() {
  args := os.Args
  if len(args) < 2 {
    usage()
  }
  conf, err := darkness_config.ParseConfig(args[1])
  if err != nil {
    log.Fatal(err)
  }
  uuid := uuid.NewV4()
  log.Println(uuid)

  log.Println(conf)
  var wg sync.WaitGroup
  wg.Add(1)
  channels := makeChannels()
  channels.redisPubLoop(conf)
  channels.redisSubLoop(conf)
  channels.ircLoop(conf)
  wg.Wait()
}

func makeChannels() Channels {
  return Channels{
    make(chan darkness_events.Event),
    make(chan darkness_events.Event),
  }
}

func (channels Channels) ircLoop(front_config darkness_config.FrontConfig) {
  go func() {
    for {
      fmt.Println("irc loop")
      // temporary, refactor
      for _, server := range front_config.Servers {
        log.Println(server)
        addr := fmt.Sprintf("%s:%d", server.Host, server.Port)
        conn, conn_err := net.DialTimeout("tcp", addr, 10*time.Second)
        if conn_err != nil {
        } else {

          channels.IrcRecvCh <- darkness_events.FrontConnected()

          var wg sync.WaitGroup
          wg.Add(1)
          fmt.Println("connected")
          channels.ircLoopSend(&wg, conn)
          channels.ircLoopRecv(&wg, conn)
          wg.Wait()
          log.Println("ircLoop: after wg.Wait()")

          channels.IrcRecvCh <- darkness_events.FrontDisconnected()

        }
      }
      time.Sleep(1 * time.Second)
    }
  }()
}

func (channels Channels) ircLoopSend(wg *sync.WaitGroup, conn net.Conn) {
  go func() {
    defer wg.Done()
    for {
      event := <-channels.IrcSendCh
      log.Println(event)
    }
  }()
}

func (channels Channels) ircLoopRecv(wg *sync.WaitGroup, conn net.Conn) {
  go func() {
    defer wg.Done()
    buf := make([]byte, 512)
    for {
      n, read_err := conn.Read(buf)
      //   n, read_err := bufio.NewReader(conn).Read(buf)
      if read_err != nil {
        log.Println("ircLoopRecv: read broken")
        break
      }
      log.Printf("irc: %d %s\n", n, buf)
      channels.IrcRecvCh <- darkness_events.FrontReceivedMessage(buf)
    }
  }()
}

func (channels Channels) redisPubLoop(front_config darkness_config.FrontConfig) {
  go func() {
    for {
      fmt.Println("redis loop")
      // temporary, refactor
      redis := front_config.Redis
      log.Println(redis)
      addr := fmt.Sprintf("%s:%d", redis.RedisHost, redis.RedisPort)
      conn, conn_err := net.DialTimeout("tcp", addr, 10*time.Second)
      if conn_err != nil {
      } else {

        log.Println("redis: connected")

        var wg sync.WaitGroup
        wg.Add(1)
        channels.redisPublishLoop(&wg, conn)
        wg.Wait()
      }
      time.Sleep(1 * time.Second)
    }
  }()
}

func (channels Channels) redisSubLoop(front_config darkness_config.FrontConfig) {
  go func() {
    for {
      fmt.Println("redis loop")
      // temporary, refactor
      redis := front_config.Redis
      log.Println(redis)
      addr := fmt.Sprintf("%s:%d", redis.RedisHost, redis.RedisPort)
      conn, conn_err := net.DialTimeout("tcp", addr, 10*time.Second)
      if conn_err != nil {
      } else {

        log.Println("redis: connected")

        var wg sync.WaitGroup
        wg.Add(1)
        channels.redisSubscribeLoop(&wg, conn)
        wg.Wait()
      }
      time.Sleep(1 * time.Second)
    }
  }()
}

/*
 * Publish events that we receive from the irc server
 */
func (channels Channels) redisPublishLoop(wg *sync.WaitGroup, conn net.Conn) {
  go func() {
    defer wg.Done()
    for message := range channels.IrcRecvCh {
      log.Println(message)
      json, err := json.Marshal(message)
      if err != nil {
        continue
      }
      darkness_redis.Publish(conn, "dbot:event", json)
    }
  }()
}

/*
 * Subscribe to events that we received from redis, which are generated by tunnels
 */
func (channels Channels) redisSubscribeLoop(wg *sync.WaitGroup, conn net.Conn) {
  go func() {
    defer wg.Done()
    buf := make([]byte, 512)
    for {
      n, read_err := bufio.NewReader(conn).Read(buf)
      if read_err != nil {
        break
      }
      log.Printf("redis: %d %s\n", n, buf)
      //   channels.IrcRecvCh <- darkness_events.TunnelSentMessage(buf)
    }
  }()
}
