package main

import (
	"bufio"
	"fmt"
	"github.com/adarqui/darkness/core/go/lib/config"
	"github.com/adarqui/darkness/core/go/lib/events"
	"log"
	"net"
	"os"
	"time"
  "sync"
)

type Channels struct {
	IrcSendCh chan darkness_events.Event
	IrcRecvCh chan darkness_events.Event
}

func usage() {
	fmt.Println("usage: ./front <config_file>")
	os.Exit(1)
}

func main() {
	args := os.Args
	if len(args) < 2 {
		usage()
	}
	conf, err := darkness_config.ParseConfig(args[1])
	if err != nil {
		log.Fatal(err)
	}
	log.Println(conf)
  var wg sync.WaitGroup
  wg.Add(1)
	channels := makeChannels()
	channels.redisLoop(conf)
	channels.ircLoop(conf)
  wg.Wait()
}

func makeChannels() Channels {
	return Channels{
		make(chan darkness_events.Event),
		make(chan darkness_events.Event),
	}
}

func (channels Channels) ircLoop(front_config darkness_config.FrontConfig) {
	go func() {
		for {
			fmt.Println("irc loop")
			// temporary, refactor
			for _, server := range front_config.Servers {
				log.Println(server)
				addr := fmt.Sprintf("%s:%d", server.Address, server.Port)
				conn, conn_err := net.DialTimeout("tcp", addr, 10*time.Second)
				if conn_err != nil {
				} else {
          var wg sync.WaitGroup
          wg.Add(1)
					fmt.Println("connected")
					channels.ircLoopSend(wg, conn)
					channels.ircLoopRecv(wg, conn)
          wg.Wait()
				}
			}
			time.Sleep(1*time.Second)
		}
	}()
}

func (channels Channels) ircLoopSend(wg sync.WaitGroup, conn net.Conn) {
	go func() {
		for {
			event := <-channels.IrcSendCh
			log.Println(event)
		}
	}()
}

func (channels Channels) ircLoopRecv(wg sync.WaitGroup, conn net.Conn) {
  defer wg.Done()
	go func() {
		buf := make([]byte, 512)
		for {
			n, read_err := bufio.NewReader(conn).Read(buf)
			if read_err != nil {
				break
			}
      log.Printf("irc: %d %s\n", n, buf)
			channels.IrcRecvCh <- darkness_events.FrontReceivedMessage(buf)
		}
	}()
}

func (channels Channels) redisLoop(front_config darkness_config.FrontConfig) {
	go func() {
		for {
			fmt.Println("redis loop")
			// temporary, refactor
			redis := front_config.Redis
			log.Println(redis)
			addr := fmt.Sprintf("%s:%d", redis.RedisHost, redis.RedisPort)
			conn, conn_err := net.DialTimeout("tcp", addr, 10*time.Second)
			if conn_err != nil {
			} else {
        var wg sync.WaitGroup
        wg.Add(1)
				channels.redisPublishLoop(wg, conn)
				channels.redisSubscribeLoop(wg, conn)
        wg.Wait()
			}
      time.Sleep(1*time.Second)
		}
	}()
}

/*
 * Publish events that we receive from the irc server
 */
func (channels Channels) redisPublishLoop(wg sync.WaitGroup, conn net.Conn) {
	go func() {
		for message := range channels.IrcRecvCh {
			log.Println(message)
		}
	}()
}

/*
 * Subscribe to events that we received from redis, which are generated by tunnels
 */
func (channels Channels) redisSubscribeLoop(wg sync.WaitGroup, conn net.Conn) {
  defer wg.Done()
	go func() {
		buf := make([]byte, 512)
		for {
			n, read_err := bufio.NewReader(conn).Read(buf)
			if read_err != nil {
				break
			}
      log.Printf("redis: %d %s\n", n, buf)
			channels.IrcRecvCh <- darkness_events.TunnelSentMessage(buf)
		}
	}()
}
